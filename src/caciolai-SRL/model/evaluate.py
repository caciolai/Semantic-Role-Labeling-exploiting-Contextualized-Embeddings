from typing import *

import torch
import torch.nn as nn
from torch.utils.data import DataLoader

from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import precision_score, recall_score, f1_score

from ..data.vocabularies import *


def compute_predictions_34(model:nn.Module, device:str, 
                        dataloader:DataLoader, 
                        srl_vocab:SemanticRolesVocabulary) -> Tuple[list, list]:
    """
    Computes and returns all the true and predicted labels of a model on the dataset.

    Args:
        model:          The model to compute the predictions.
        device:         CPU or CUDA.
        dataloader:     The dataset to classify.
        label_dict:     The dictionary for the labels.
    
    Returns:
        The true and predicted labels for the data in dataset.
    """
    all_y_pred = list()
    all_y_true = list()
    model.eval()
    with torch.no_grad():
        for batch in tqdm(dataloader, desc="Computing predictions", total=len(dataloader)):
            lengths = batch["length"].to(device)
            pred_frame = batch["pred_frame"].to(device)
            word = batch["word"].to(device)
            lemma = batch["lemma"].to(device)
            pos_tag = batch["pos_tag"].to(device)
            bert_sent = batch["bert_sent"].to(device)
            pred_pos = batch["pred_pos"].to(device)
            pred_mask = batch["pred_mask"].to(device)

            y_true = batch["srl"]

            y_pred = model(lengths, pred_frame, pred_pos, pred_mask, 
                           word, lemma, pos_tag, bert_sent)
            
            y_pred = torch.argmax(y_pred, -1).view(-1).cpu()
            y_true = y_true.view(-1)
            
            valid_indices = y_true != srl_vocab['<pad>']
            valid_labels = y_true[valid_indices]
            valid_predictions = y_pred[valid_indices]
            
            all_y_true.extend(valid_labels.tolist())
            all_y_pred.extend(valid_predictions.tolist())
    
    return all_y_true, all_y_pred

def compute_predictions_234(model:nn.Module, device:str, 
                        dataloader:DataLoader, 
                        srl_vocab:SemanticRolesVocabulary,
                        pf_vocab:PredicateFramesVocabulary) -> Tuple[list, list, list, list]:
    """
    Computes and returns all the true and predicted labels of a model on the dataset.

    Args:
        model:          The model to compute the predictions.
        device:         CPU or CUDA.
        dataloader:     The dataset to classify.
        label_dict:     The dictionary for the labels.
    
    Returns:
        The true and predicted labels for the data in dataset.
    """
    all_true_pf = list()
    all_pred_pf = list()

    all_true_srl = list()
    all_pred_srl = list()

    model.eval()
    with torch.no_grad():
        for batch in tqdm(dataloader, desc="Computing predictions", total=len(dataloader)):
            lengths = batch["length"].to(device)
            lemma = batch["lemma"].to(device)
            word = batch["word"].to(device)
            pos_tag = batch["pos_tag"].to(device)
            bert_sent = batch["bert_sent"].to(device)
            pred_pos = batch["pred_pos"].to(device)
            pred_mask = batch["pred_mask"].to(device)

            true_srl = batch["srl"].view(-1)
            true_pf = batch["pred_frame"].view(-1)

            pred_pf, pred_srl = model(lengths, pred_pos, pred_mask, 
                                      word, lemma, pos_tag, bert_sent)
            
            pred_pf = torch.argmax(pred_pf, -1).view(-1).cpu()
            pred_srl = torch.argmax(pred_srl, -1).view(-1).cpu()

            valid_indices = true_pf != pf_vocab['<pad>']
            valid_labels = true_pf[valid_indices]
            valid_predictions = pred_pf[valid_indices]

            all_true_pf.extend(valid_labels.tolist())
            all_pred_pf.extend(valid_predictions.tolist())

            valid_indices = true_srl != srl_vocab['<pad>']
            valid_labels = true_srl[valid_indices]
            valid_predictions = pred_srl[valid_indices]

            all_true_srl.extend(valid_labels.tolist())
            all_pred_srl.extend(valid_predictions.tolist())
    
    
    return all_true_pf, all_pred_pf, \
            all_true_srl, all_pred_srl

def compute_classification_report(y_true:List[int], y_pred:List[int], 
                                  srl_vocab:SemanticRolesVocabulary, 
                                  ignored_labels=[]):
    """
    Computes and prints the classification report of the predictions of a model.

    Args:
        y_true:         Ground truth labels.
        y_pred:         Predicted labels.
        label_dict:     Vocabulary with the labels for decoding.
    """
    # discarding roles that are not in the test data
    for role, role_id in srl_vocab.stoi.items():
        if role_id not in y_true and role_id not in y_pred:
            if role not in ignored_labels:
                ignored_labels.append(role)

    print("Ignoring labels:", ignored_labels)

    print(classification_report(
        y_true, y_pred, zero_division=0, digits=4,
        labels=[i for l, i in srl_vocab.stoi.items() if l not in ignored_labels],
        target_names=[l for l, i in srl_vocab.stoi.items() if l not in ignored_labels]
    ))

def custom_f1_score(y_true, y_pred, srl_vocab: PredicateFramesVocabulary):
    y_true = y_true.detach().cpu()
    y_pred = y_pred.detach().cpu()
    y_pred = torch.argmax(y_pred, -1)
        
    valid_indices = y_true != srl_vocab['<pad>']
    valid_labels = y_true[valid_indices]
    valid_predictions = y_pred[valid_indices]

    y_true = valid_labels.numpy()
    y_pred = valid_predictions.numpy()

    batch_f1_score = f1_score(y_true, y_pred, average='macro')
    return batch_f1_score